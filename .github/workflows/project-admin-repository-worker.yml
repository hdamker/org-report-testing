name: Repository Worker

on:
  workflow_call:
    inputs:
      repository_name:
        required: true
        type: string
      repository_full_name:
        required: true
        type: string
      default_branch:
        required: true
        type: string
      operation:
        required: true
        type: string
      dry_run:
        required: true
        type: boolean

jobs:
  execute-operation:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository_full_name }}
          token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          ref: ${{ inputs.default_branch }}

      - name: Debug Token Usage
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            // The token is passed to the action but not directly accessible
            // Let's test what we can access and determine token type by behavior
            
            console.log('=== Token Debug Information ===');
            
            try {
              // Test basic authentication
              const user = await github.rest.users.getAuthenticated();
              console.log('âœ… Authenticated as:', user.data.login);
              console.log('- User type:', user.data.type);
              
              // Test if we can access the target repository
              const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
              console.log(`\nTesting access to ${owner}/${repo}:`);
              
              try {
                const repoInfo = await github.rest.repos.get({
                  owner: owner,
                  repo: repo
                });
                console.log('âœ… Can read repository information');
                console.log('- Repository:', repoInfo.data.full_name);
                console.log('- Private:', repoInfo.data.private);
              } catch (repoError) {
                console.log('âŒ Cannot access repository:', repoError.message);
                console.log('- Status:', repoError.status);
              }
              
              // Test Contents API access (the failing operation)
              try {
                await github.rest.repos.getContent({
                  owner: owner,
                  repo: repo,
                  path: 'README.md'  // Try a common file
                });
                console.log('âœ… Can read file contents via API');
              } catch (contentError) {
                console.log('âŒ Cannot read contents via API:', contentError.message);
                console.log('- Status:', contentError.status);
                
                if (contentError.status === 403) {
                  console.log('ðŸ” This suggests token lacks Contents permission or cross-org access');
                }
              }
              
            } catch (authError) {
              console.log('âŒ Authentication failed:', authError.message);
              console.log('- Status:', authError.status);
              
              if (authError.status === 401) {
                console.log('ðŸ” This suggests CAMARA_TOKEN secret is not being used');
              }
            }
            
            // Check if we're using the fallback token
            console.log('\n=== Secret Analysis ===');
            console.log('Expected: Using CAMARA_TOKEN (your custom token)');
            console.log('Reality: Will be determined by permission test results above');
        env:
          CAMARA_TOKEN_EXISTS: ${{ secrets.CAMARA_TOKEN != '' }}

      - name: Check Repository Permissions
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            
            console.log(`Checking permissions for user ${context.actor} on ${owner}/${repo}`);
            console.log(`Operation: ${{ inputs.operation }}`);
            
            // Only do strict permission check for wiki operations
            if ('${{ inputs.operation }}' !== 'disable-wiki') {
              console.log('âœ… Permission check skipped for non-wiki operations');
              return;
            }
            
            try {
              // First, try to get basic repository info to verify access
              const repoInfo = await github.rest.repos.get({
                owner: owner,
                repo: repo
              });
              
              console.log(`Repository access confirmed: ${repoInfo.data.full_name}`);
              
              // Try to check user's permission level
              let hasAdminAccess = false;
              let permissionSource = 'unknown';
              
              // Method 1: Direct collaborator permission check
              try {
                const collaboratorPermission = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: owner,
                  repo: repo,
                  username: context.actor
                });
                
                const permission = collaboratorPermission.data.permission;
                hasAdminAccess = permission === 'admin';
                permissionSource = `direct collaborator (${permission})`;
                
                console.log(`Direct permission check: ${permission}`);
                
              } catch (collabError) {
                console.log(`Direct collaborator check failed: ${collabError.message}`);
                
                // Method 2: Check if user is organization admin
                try {
                  const orgMembership = await github.rest.orgs.getMembershipForUser({
                    org: owner,
                    username: context.actor
                  });
                  
                  hasAdminAccess = orgMembership.data.role === 'admin';
                  permissionSource = `org membership (${orgMembership.data.role})`;
                  
                  console.log(`Organization membership check: ${orgMembership.data.role}`);
                  
                } catch (orgError) {
                  console.log(`Organization membership check failed: ${orgError.message}`);
                  
                  // Method 3: Try to make a test API call that requires admin access
                  try {
                    // Try to get repository topics (requires admin for private repos)
                    const topics = await github.rest.repos.getAllTopics({
                      owner: owner,
                      repo: repo
                    });
                    
                    hasAdminAccess = true; // If we can get topics, we likely have sufficient access
                    permissionSource = 'inferred from API access';
                    console.log('âœ… Inferred admin access from successful API calls');
                    
                  } catch (topicsError) {
                    console.log(`Topics check failed: ${topicsError.message}`);
                    
                    // If all methods fail, we'll proceed but warn the user
                    console.log('âš ï¸ Could not determine permission level - proceeding with operation');
                    console.log('If the wiki operation fails, ensure your token has Administration: Write permission');
                    hasAdminAccess = true; // Assume true and let the actual operation fail if needed
                    permissionSource = 'assumed (verification failed)';
                  }
                }
              }
              
              console.log(`Final permission assessment: ${hasAdminAccess ? 'ADMIN' : 'NO ADMIN'} via ${permissionSource}`);
              
              if (!hasAdminAccess && permissionSource !== 'assumed (verification failed)') {
                core.warning(`âš ï¸ Insufficient permissions detected: Admin access may be required to disable wiki. Current user: ${context.actor}`);
                core.warning(`Permission source: ${permissionSource}`);
                core.warning(`If this operation fails, ensure your FGPAT has 'Administration: Write' permission for the repository.`);
                
                // Don't fail here - let the actual operation attempt and fail if needed
                console.log('Proceeding with operation - will fail at wiki update step if permissions insufficient');
              } else {
                console.log('âœ… Permission check passed');
              }
              
            } catch (error) {
              console.error('Error during permission check:', error.message);
              console.log('âš ï¸ Permission verification failed - proceeding with operation');
              console.log('If the wiki operation fails, check that your FGPAT has the required permissions');
            }

      - name: Execute Operation - Disable Wiki
        if: inputs.operation == 'disable-wiki'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            
            try {
              // Get repository information to check if wiki is enabled
              const repoInfo = await github.rest.repos.get({
                owner: owner,
                repo: repo
              });
              
              if (!repoInfo.data.has_wiki) {
                console.log('âœ… Wiki is already disabled');
                core.exportVariable('status', 'no-change');
                return;
              }
              
              console.log('Wiki is currently enabled, checking for content...');
              
              // Check if wiki has any content by trying to list wiki pages
              let hasWikiContent = false;
              try {
                const wikiPages = await github.request('GET /repos/{owner}/{repo}/wiki', {
                  owner: owner,
                  repo: repo
                });
                // If we get here without error, wiki has content
                hasWikiContent = true;
                console.log('âš ï¸ Wiki has content - will not disable for safety');
              } catch (wikiError) {
                if (wikiError.status === 404) {
                  console.log('âœ… Wiki has no content - safe to disable');
                  hasWikiContent = false;
                } else {
                  console.log('Error checking wiki content:', wikiError.message);
                  // Assume it has content to be safe
                  hasWikiContent = true;
                }
              }
              
              if (hasWikiContent) {
                console.log('âš ï¸ Wiki contains content - skipping disable for safety');
                core.exportVariable('status', 'wiki-has-content');
                return;
              }
              
              // Wiki is enabled but empty - safe to disable
              if (${{ inputs.dry_run }}) {
                console.log('ðŸ§ª DRY RUN: Would disable wiki (currently enabled but empty)');
                core.exportVariable('status', 'would-disable-wiki');
              } else {
                try {
                  await github.rest.repos.update({
                    owner: owner,
                    repo: repo,
                    has_wiki: false
                  });
                  console.log('âœ… Wiki disabled successfully');
                  core.exportVariable('status', 'wiki-disabled');
                } catch (updateError) {
                  console.error('âŒ Error disabling wiki:', updateError.message);
                  
                  // Provide specific error messages based on common issues
                  if (updateError.status === 403) {
                    core.setFailed(`âŒ Permission denied: Insufficient permissions to disable wiki. You need admin access to repository ${owner}/${repo}. Please ensure your token has 'repo' scope and you are an admin of the repository.`);
                  } else if (updateError.status === 404) {
                    core.setFailed(`âŒ Repository not found: ${owner}/${repo} may not exist or token lacks access.`);
                  } else if (updateError.status === 422) {
                    core.setFailed(`âŒ Invalid request: The repository settings could not be updated. This may be due to organization policies or repository restrictions.`);
                  } else {
                    core.setFailed(`âŒ Failed to disable wiki: ${updateError.message} (HTTP ${updateError.status})`);
                  }
                  throw updateError;
                }
              }
              
            } catch (error) {
              console.error('âŒ Error processing wiki operation:', error.message);
              if (!error.message.includes('Permission denied') && !error.message.includes('Failed to disable wiki')) {
                core.setFailed(`âŒ Wiki operation failed: ${error.message}`);
              }
            }

      - name: Execute Operation - Add Changelog CODEOWNERS
        if: inputs.operation == 'add-changelog-codeowners'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const [owner, repo] = '${{ inputs.repository_full_name }}'.split('/');
            
            console.log(`Processing repository: ${owner}/${repo}`);
            
            // Define the lines to add
            const changelogLines = `# The following line ensures that the release-management_reviewers team will automatically added as reviewers
            # if a pull requests is changing the CHANGELOG.MD (aka "release PR") and that such PRs can only be merged with an approval from a team member.
            /CHANGELOG.MD @camaraproject/release-management_reviewers`;
            
            try {
              let currentContent = '';
              let currentSha = null;
              let fileExists = false;
              
              // Try to get existing CODEOWNERS file
              try {
                const fileResponse = await github.rest.repos.getContent({
                  owner: owner,
                  repo: repo,
                  path: 'CODEOWNERS'
                });
                
                if (fileResponse.data.content) {
                  currentContent = Buffer.from(fileResponse.data.content, 'base64').toString('utf8');
                  currentSha = fileResponse.data.sha;
                  fileExists = true;
                  console.log('âœ… Found existing CODEOWNERS file');
                } else {
                  console.log('âŒ CODEOWNERS file exists but has no content');
                  fileExists = false;
                }
              } catch (getError) {
                if (getError.status === 404) {
                  console.log('âš ï¸ CODEOWNERS file does not exist in this repository');
                  core.warning(`Repository ${owner}/${repo} does not have a CODEOWNERS file. This should be investigated as all CAMARA repositories are expected to have CODEOWNERS files.`);
                  core.exportVariable('status', 'no-codeowners-file');
                  return;
                } else {
                  throw getError;
                }
              }
              
              if (!fileExists) {
                console.log('âš ï¸ CODEOWNERS file not found - skipping operation');
                core.warning(`Repository ${owner}/${repo} does not have a CODEOWNERS file. Operation skipped.`);
                core.exportVariable('status', 'no-codeowners-file');
                return;
              }
              
              // Check if CHANGELOG.MD rule already exists
              if (currentContent.includes('/CHANGELOG.MD')) {
                console.log('âœ… CHANGELOG.MD CODEOWNERS rule already exists');
                core.exportVariable('status', 'no-change');
                return;
              }
              
              // Prepare new content - only modify existing files
              const newContent = currentContent.trim() + '\n\n' + changelogLines;
              console.log('ðŸ“ Adding CHANGELOG.MD rule to existing CODEOWNERS');
              
              // Dry run check
              if (${{ inputs.dry_run }}) {
                console.log('ðŸ§ª DRY RUN: Would add CHANGELOG.MD rule to existing CODEOWNERS');
                console.log('--- Content to be added ---');
                console.log(changelogLines);
                console.log('--- End content ---');
                core.exportVariable('status', 'would-modify');
                return;
              }
              
              // Update the existing file
              const updateParams = {
                owner: owner,
                repo: repo,
                path: 'CODEOWNERS',
                message: 'chore: add CHANGELOG.MD to CODEOWNERS for release management\n\nApplied via project-admin workflow',
                content: Buffer.from(newContent).toString('base64'),
                sha: currentSha
              };
              
              const updateResponse = await github.rest.repos.createOrUpdateFileContents(updateParams);
              
              console.log('âœ… CODEOWNERS file updated successfully');
              console.log(`Commit SHA: ${updateResponse.data.commit.sha}`);
              core.exportVariable('status', 'modified');
              
            } catch (error) {
              console.error('âŒ Error updating CODEOWNERS:', error.message);
              
              // Provide specific error messages
              if (error.status === 403) {
                core.setFailed(`âŒ Permission denied: Your token needs 'Contents: Write' permission for repository ${owner}/${repo}`);
              } else if (error.status === 404) {
                core.setFailed(`âŒ Repository not found: ${owner}/${repo} may not exist or token lacks access`);
              } else if (error.status === 409) {
                core.setFailed(`âŒ Conflict: CODEOWNERS file was modified by someone else. Please retry the operation.`);
              } else {
                core.setFailed(`âŒ Failed to update CODEOWNERS: ${error.message} (HTTP ${error.status})`);
              }
              throw error;
            }

      - name: Check for changes
        id: check-changes
        run: |
          # This step is now mainly for wiki operations or future git-based operations
          # CODEOWNERS operation uses GitHub API directly and doesn't need git commits
          if [ "${{ inputs.operation }}" == "add-changelog-codeowners" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "CODEOWNERS operation uses GitHub API - no git changes to commit"
          else
            if git diff --quiet && git diff --cached --quiet; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "Changes detected:"
              git status --porcelain
            fi
          fi

      - name: Commit and Push Changes
        if: steps.check-changes.outputs.has_changes == 'true' && inputs.dry_run == false
        run: |
          echo "Committing changes..."
          
          # Verify git config is set
          echo "Current git configuration:"
          git config --get user.name || echo "No user.name set"
          git config --get user.email || echo "No user.email set"
          
          # Set git config locally if not already set
          git config user.name "CAMARA Admin Bot"
          git config user.email "admin-bot@camaraproject.org"
          
          echo "Git configuration after local setup:"
          git config --get user.name
          git config --get user.email
          
          # Show what we're about to commit
          echo "Files to be committed:"
          git status --porcelain
          
          # Add and commit changes
          git add .
          git commit -m "chore: automated CAMARA project update - ${{ inputs.operation }}

          Applied via project-admin workflow
          Repository: ${{ inputs.repository_name }}
          Operation: ${{ inputs.operation }}"
          
          # Push changes
          echo "Pushing changes to ${{ inputs.default_branch }}..."
          git push origin ${{ inputs.default_branch }}

      - name: Create summary
        run: |
          echo "## Repository: ${{ inputs.repository_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Operation**: ${{ inputs.operation }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ env.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: ${{ inputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.operation }}" == "add-changelog-codeowners" ]; then
            echo "**Method**: GitHub Contents API" >> $GITHUB_STEP_SUMMARY
            if [ "${{ inputs.dry_run }}" == "true" ]; then
              echo "**Note**: This was a dry run - no changes were made via API." >> $GITHUB_STEP_SUMMARY
            else
              case "${{ env.status }}" in
                "modified")
                  echo "**Note**: CHANGELOG.MD rule added to existing CODEOWNERS file." >> $GITHUB_STEP_SUMMARY
                  ;;
                "no-change")
                  echo "**Note**: CHANGELOG.MD rule already exists - no changes needed." >> $GITHUB_STEP_SUMMARY
                  ;;
                "no-codeowners-file")
                  echo "**Note**: âš ï¸ Repository has no CODEOWNERS file - operation skipped. This should be investigated." >> $GITHUB_STEP_SUMMARY
                  ;;
              esac
            fi
          else
            echo "**Has Changes**: ${{ steps.check-changes.outputs.has_changes }}" >> $GITHUB_STEP_SUMMARY
            if [ "${{ inputs.dry_run }}" == "true" ]; then
              echo "**Note**: This was a dry run - no changes were committed." >> $GITHUB_STEP_SUMMARY
            elif [ "${{ steps.check-changes.outputs.has_changes }}" == "true" ]; then
              echo "**Note**: Changes have been committed and pushed." >> $GITHUB_STEP_SUMMARY
            fi
          fi
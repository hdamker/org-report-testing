name: Generate CAMARA Project Reports

on:
  workflow_dispatch:
    inputs:
      report_type:
        description: 'Type of report to generate'
        required: true
        type: choice
        options:
          - 'repository-overview'
          - 'api-releases'
          - 'security-analysis'
        default: 'repository-overview'
      
      include_archived:
        description: 'Include archived repositories'
        required: false
        type: boolean
        default: false
      
      detailed_activity:
        description: 'Include detailed activity analysis (slower but more accurate)'
        required: false
        type: boolean
        default: false

  schedule:
    # Run weekly on Mondays at 07:35 UTC
    - cron: '35 7 * * 1'

jobs:
  generate-report:
    runs-on: ubuntu-latest
    steps:

      - name: Generate Repository Overview Report
        if: github.event.inputs.report_type == 'repository-overview' || github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            const includeArchived = '${{ github.event.inputs.include_archived }}' === 'true';
            const detailedActivity = '${{ github.event.inputs.detailed_activity }}' === 'true';
            
            console.log(`üöÄ Starting CAMARA repository overview report for ${org}`);
            console.log(`üìÖ Report generation started at: ${new Date().toISOString()}`);
            console.log(`‚öôÔ∏è Configuration: includeArchived=${includeArchived}, detailedActivity=${detailedActivity}`);
            
            // Helper function to determine repository type based on topics
            function getRepositoryType(topics) {
              if (topics.includes('sandbox-api-repository')) return 'Sandbox';
              if (topics.includes('incubating-api-repository')) return 'Incubating';
              if (topics.includes('workinggroup')) return 'Working Group';
              return 'Other';
            }
            
            // Helper function to get last activity date from multiple sources (only used if detailedActivity is true)
            async function getLastActivityDate(repo) {
              let lastActivity = new Date(repo.updated_at);
              let activityLink = repo.html_url;
              let activityType = 'repository';
              
              try {
                console.log(`    üîç Getting detailed activity for ${repo.name}...`);
                // Check recent commits
                const commits = await github.rest.repos.listCommits({
                  owner: org,
                  repo: repo.name,
                  per_page: 1
                });
                if (commits.data.length > 0) {
                  const commitDate = new Date(commits.data[0].commit.committer.date);
                  if (commitDate > lastActivity) {
                    lastActivity = commitDate;
                    activityLink = commits.data[0].html_url;
                    activityType = 'commit';
                    console.log(`      ‚úÖ Latest commit: ${commitDate.toDateString()}`);
                  }
                }
                
                // Check recent issues
                const issues = await github.rest.issues.listForRepo({
                  owner: org,
                  repo: repo.name,
                  state: 'all',
                  sort: 'updated',
                  per_page: 1
                });
                if (issues.data.length > 0) {
                  const issueDate = new Date(issues.data[0].updated_at);
                  if (issueDate > lastActivity) {
                    lastActivity = issueDate;
                    activityLink = issues.data[0].html_url;
                    activityType = issues.data[0].pull_request ? 'pull_request' : 'issue';
                    console.log(`      ‚úÖ Latest issue/PR: ${issueDate.toDateString()}`);
                  }
                }
                
                // Check recent pull requests (in case issues API missed some)
                const prs = await github.rest.pulls.list({
                  owner: org,
                  repo: repo.name,
                  state: 'all',
                  sort: 'updated',
                  per_page: 1
                });
                if (prs.data.length > 0) {
                  const prDate = new Date(prs.data[0].updated_at);
                  if (prDate > lastActivity) {
                    lastActivity = prDate;
                    activityLink = prs.data[0].html_url;
                    activityType = 'pull_request';
                    console.log(`      ‚úÖ Latest PR: ${prDate.toDateString()}`);
                  }
                }
                console.log(`    üìä Final activity: ${lastActivity.toDateString()} (${activityType})`);
              } catch (error) {
                console.log(`    ‚ùå Could not get detailed activity for ${repo.name}: ${error.message}`);
              }
              
              return {
                date: lastActivity,
                link: activityLink,
                type: activityType
              };
            }
            
            console.log(`üîç Step 1: Fetching all repositories from ${org}...`);
            
            // Get all repositories
            let allRepos = [];
            let page = 1;
            
            while (true) {
              console.log(`  üì• Fetching repositories page ${page}...`);
              const response = await github.rest.repos.listForOrg({
                org: org,
                type: 'all',
                sort: 'name',
                per_page: 100,
                page: page
              });
              
              if (response.data.length === 0) break;
              console.log(`  üìä Page ${page}: ${response.data.length} repositories`);
              allRepos = allRepos.concat(response.data);
              page++;
            }
            
            console.log(`‚úÖ Step 1 Complete: Found ${allRepos.length} total repositories`);
            
            // Filter repositories
            const filteredRepos = includeArchived ? allRepos : allRepos.filter(r => !r.archived);
            
            console.log(`üîç Step 2: Processing ${filteredRepos.length} repositories${includeArchived ? '' : ' (excluding archived)'}...`);
            if (detailedActivity) {
              console.log('‚ö†Ô∏è Detailed activity analysis enabled - this will take longer but provide more accurate activity dates');
            }
            
            // Enrich repository data with additional information
            const enrichedRepos = [];
            for (let i = 0; i < filteredRepos.length; i++) {
              const repo = filteredRepos[i];
              console.log(`üì¶ [${i + 1}/${filteredRepos.length}] Processing ${repo.name}...`);
              
              try {
                console.log(`  üè∑Ô∏è Getting topics...`);
                // Get repository topics
                const topics = await github.rest.repos.getAllTopics({
                  owner: org,
                  repo: repo.name
                });
                
                const repoType = getRepositoryType(topics.data.names);
                console.log(`  üìÇ Type: ${repoType} (topics: ${topics.data.names.join(', ') || 'none'})`);
                
                console.log(`  üìä Getting open issues and PRs...`);
                // Get open issues and PRs count (avoiding deprecated search API)
                const openPRs = await github.rest.pulls.list({
                  owner: org,
                  repo: repo.name,
                  state: 'open',
                  per_page: 100
                }).then(async (response) => {
                  let total = response.data.length;
                  
                  // If we got 100 results, there might be more - paginate
                  if (response.data.length === 100) {
                    console.log(`    üìà Repository has 100+ PRs, paginating...`);
                    let page = 2;
                    while (true) {
                      const nextPage = await github.rest.pulls.list({
                        owner: org,
                        repo: repo.name,
                        state: 'open',
                        per_page: 100,
                        page: page
                      });
                      
                      if (nextPage.data.length === 0) break;
                      total += nextPage.data.length;
                      page++;
                      
                      // Safety limit to avoid infinite loops
                      if (page > 50) break;
                    }
                  }
                  
                  return total;
                }).catch(() => 0);
                
                // Calculate open issues count (repo.open_issues_count includes both issues and PRs)
                const openIssues = Math.max(0, (repo.open_issues_count || 0) - openPRs);
                
                console.log(`  üìã Open issues: ${openIssues}, Open PRs: ${openPRs}`);
                
                // Get last activity date (only if detailed analysis is requested)
                const detailedActivityInfo = detailedActivity ? await getLastActivityDate(repo) : null;
                const lastActivity = detailedActivityInfo ? detailedActivityInfo.date : new Date(repo.updated_at);
                
                console.log(`  üìÖ Last activity: ${lastActivity.toDateString()}${detailedActivity ? ` (${detailedActivityInfo.type})` : ' (simple)'}`);
                
                enrichedRepos.push({
                  ...repo,
                  repo_type: repoType,
                  topics: topics.data.names,
                  open_issues_count: openIssues,
                  open_prs_count: openPRs,
                  last_activity_date: lastActivity,
                  detailed_activity: detailedActivityInfo, // Store detailed activity info
                  simple_activity_date: new Date(repo.updated_at) // Always store simple date for comparison
                });
                
                console.log(`  ‚úÖ Completed ${repo.name}`);
                
              } catch (error) {
                console.log(`  ‚ùå Error processing ${repo.name}: ${error.message}`);
                // Add with minimal data if API calls fail
                enrichedRepos.push({
                  ...repo,
                  repo_type: 'Other',
                  topics: [],
                  open_issues_count: repo.open_issues_count || 0,
                  open_prs_count: 0,
                  last_activity_date: new Date(repo.updated_at),
                  detailed_activity: null,
                  simple_activity_date: new Date(repo.updated_at)
                });
              }
            }
            
            console.log(`‚úÖ Step 2 Complete: Repository processing finished`);
            console.log(`üìä Repository Summary:`);
            const typeBreakdown = {};
            enrichedRepos.forEach(repo => {
              typeBreakdown[repo.repo_type] = (typeBreakdown[repo.repo_type] || 0) + 1;
            });
            Object.entries(typeBreakdown).forEach(([type, count]) => {
              console.log(`  - ${type}: ${count}`);
            });
            
            console.log(`üìù Step 3: Generating comprehensive report...`);
            
            // Generate report
            let report = `# CAMARA Project Repository Overview\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**Organization**: ${org}\n`;
            report += `**Total Repositories**: ${enrichedRepos.length}\n`;
            if (!includeArchived) {
              report += `**Archived Repositories Excluded**: ${allRepos.length - enrichedRepos.length}\n`;
            }
            report += `**Detailed Activity Analysis**: ${detailedActivity ? 'Enabled' : 'Disabled (using repository updated_at)'}\n`;
            report += `\n`;
            
            // Repository type statistics
            const typeStats = {
              'Sandbox': enrichedRepos.filter(r => r.repo_type === 'Sandbox').length,
              'Incubating': enrichedRepos.filter(r => r.repo_type === 'Incubating').length,
              'Working Group': enrichedRepos.filter(r => r.repo_type === 'Working Group').length,
              'Other': enrichedRepos.filter(r => r.repo_type === 'Other').length
            };
            
            // General statistics
            const stats = {
              total: enrichedRepos.length,
              public: enrichedRepos.filter(r => !r.private).length,
              private: enrichedRepos.filter(r => r.private).length,
              archived: enrichedRepos.filter(r => r.archived).length,
              forked: enrichedRepos.filter(r => r.fork).length,
              hasIssues: enrichedRepos.filter(r => r.has_issues).length,
              hasWiki: enrichedRepos.filter(r => r.has_wiki).length,
              languages: [...new Set(enrichedRepos.map(r => r.language).filter(l => l))],
              totalOpenIssues: enrichedRepos.reduce((acc, r) => acc + r.open_issues_count, 0),
              totalOpenPRs: enrichedRepos.reduce((acc, r) => acc + r.open_prs_count, 0)
            };
            
            report += `## Repository Statistics\n\n`;
            report += `### General Statistics\n`;
            report += `- **Total Repositories**: ${stats.total}\n`;
            report += `- **Public**: ${stats.public}\n`;
            report += `- **Private**: ${stats.private}\n`;
            if (stats.archived > 0) report += `- **Archived**: ${stats.archived}\n`;
            report += `- **Forked**: ${stats.forked}\n`;
            report += `- **With Issues Enabled**: ${stats.hasIssues}\n`;
            report += `- **With Wiki Enabled**: ${stats.hasWiki}\n`;
            report += `- **Programming Languages**: ${stats.languages.length} (${stats.languages.join(', ')})\n`;
            report += `- **Total Open Issues**: ${stats.totalOpenIssues}\n`;
            report += `- **Total Open Pull Requests**: ${stats.totalOpenPRs}\n\n`;
            
            report += `### Repository Types\n`;
            report += `- **Sandbox APIs**: ${typeStats['Sandbox']}\n`;
            report += `- **Incubating APIs**: ${typeStats['Incubating']}\n`;
            report += `- **Working Groups**: ${typeStats['Working Group']}\n`;
            report += `- **Other**: ${typeStats['Other']}\n\n`;
            
            // Activity Analysis Comparison (only if detailed analysis is enabled)
            if (detailedActivity) {
              report += `## Activity Date Comparison\n\n`;
              report += `*Comparing GitHub's updated_at vs detailed activity analysis*\n\n`;
              
              // Calculate differences
              const repositories = enrichedRepos.map(repo => {
                const simpleDate = repo.simple_activity_date;
                const detailedDate = repo.detailed_activity ? repo.detailed_activity.date : simpleDate;
                const timeDiff = Math.abs(detailedDate - simpleDate) / (1000 * 60 * 60 * 24); // days
                
                return {
                  name: repo.name,
                  repo_type: repo.repo_type,
                  html_url: repo.html_url,
                  simple_date: simpleDate,
                  detailed_date: detailedDate,
                  detailed_link: repo.detailed_activity ? repo.detailed_activity.link : repo.html_url,
                  activity_type: repo.detailed_activity ? repo.detailed_activity.type : 'repository',
                  days_difference: timeDiff
                };
              });
              
              // Find repositories with significant differences (more than 1 day)
              const significantDifferences = repositories.filter(r => r.days_difference > 1);
              const identicalDates = repositories.filter(r => r.days_difference <= 1);
              
              report += `### Summary\n`;
              report += `- **Repositories with identical/similar dates**: ${identicalDates.length}\n`;
              report += `- **Repositories with significant differences (>1 day)**: ${significantDifferences.length}\n\n`;
              
              if (significantDifferences.length > 0) {
                report += `### Repositories with Significant Date Differences\n\n`;
                report += `| Repository | Type | GitHub Updated | Detailed Activity | Difference | Activity Type |\n`;
                report += `|------------|------|----------------|-------------------|------------|---------------|\n`;
                
                // Sort by difference (largest first)
                significantDifferences.sort((a, b) => b.days_difference - a.days_difference);
                
                for (const repo of significantDifferences.slice(0, 20)) { // Show top 20
                  const simpleFormatted = repo.simple_date.toLocaleDateString();
                  const detailedFormatted = repo.detailed_date.toLocaleDateString();
                  const activityLink = `[${detailedFormatted}](${repo.detailed_link})`;
                  const daysDiff = Math.round(repo.days_difference);
                  
                  report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${simpleFormatted} | ${activityLink} | ${daysDiff} days | ${repo.activity_type} |\n`;
                }
                
                if (significantDifferences.length > 20) {
                  report += `\n*Showing top 20 of ${significantDifferences.length} repositories with differences*\n`;
                }
                report += `\n`;
              }
              
              // Sample of all repositories for comparison
              report += `### Sample Activity Date Comparison (First 15 Repositories)\n\n`;
              report += `| Repository | GitHub Updated | Detailed Activity | Activity Type |\n`;
              report += `|------------|----------------|-------------------|---------------|\n`;
              
              for (const repo of repositories.sort((a, b) => a.name.localeCompare(b.name)).slice(0, 15)) {
                const simpleFormatted = repo.simple_date.toLocaleDateString();
                const detailedFormatted = repo.detailed_date.toLocaleDateString();
                const activityLink = `[${detailedFormatted}](${repo.detailed_link})`;
                
                report += `| [${repo.name}](${repo.html_url}) | ${simpleFormatted} | ${activityLink} | ${repo.activity_type} |\n`;
              }
              report += `\n`;
            }
            
            // Top repositories by stars
            const topStarred = enrichedRepos
              .sort((a, b) => b.stargazers_count - a.stargazers_count)
              .slice(0, 10)
              .filter(r => r.stargazers_count > 0);
            
            if (topStarred.length > 0) {
              report += `## Top Repositories by Stars\n\n`;
              report += `| Repository | Type | Stars | Language | Open Issues | Open PRs |\n`;
              report += `|------------|------|-------|----------|-------------|----------|\n`;
              
              for (const repo of topStarred) {
                const language = repo.language || 'N/A';
                
                report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${repo.stargazers_count} | ${language} | ${repo.open_issues_count} | ${repo.open_prs_count} |\n`;
              }
              report += `\n`;
            }
            
            // Recent activity (using the activity date available)
            const recentlyActive = enrichedRepos
              .sort((a, b) => new Date(b.last_activity_date) - new Date(a.last_activity_date))
              .slice(0, 15);
            
            const activityTitle = detailedActivity ? 'Most Recently Active Repositories' : 'Recently Updated Repositories';
            const activityNote = detailedActivity ? '*Based on detailed activity analysis*' : '*Based on repository updated_at timestamp*';
            
            report += `## ${activityTitle}\n\n`;
            report += `${activityNote}\n\n`;
            report += `| Repository | Type | Last Activity | Open Issues | Open PRs | Language |\n`;
            report += `|------------|------|---------------|-------------|----------|----------|\n`;
            
            for (const repo of recentlyActive) {
              const lastActivity = new Date(repo.last_activity_date).toLocaleDateString();
              const language = repo.language || 'N/A';
              const isArchived = repo.archived ? ' üì¶' : '';
              
              report += `| [${repo.name}](${repo.html_url})${isArchived} | ${repo.repo_type} | ${lastActivity} | ${repo.open_issues_count} | ${repo.open_prs_count} | ${language} |\n`;
            }
            report += `\n`;
            
            // Complete repository list grouped by type
            const reposByType = {
              'Working Group': enrichedRepos.filter(r => r.repo_type === 'Working Group').sort((a, b) => a.name.localeCompare(b.name)),
              'Incubating': enrichedRepos.filter(r => r.repo_type === 'Incubating').sort((a, b) => a.name.localeCompare(b.name)),
              'Sandbox': enrichedRepos.filter(r => r.repo_type === 'Sandbox').sort((a, b) => a.name.localeCompare(b.name)),
              'Other': enrichedRepos.filter(r => r.repo_type === 'Other').sort((a, b) => a.name.localeCompare(b.name))
            };
            
            report += `## Complete Repository List by Type\n\n`;
            
            for (const [type, repos] of Object.entries(reposByType)) {
              if (repos.length === 0) continue;
              
              report += `### ${type} Repositories (${repos.length})\n\n`;
              report += `| Repository | Visibility | Stars | Language | Open Issues | Open PRs | Last Activity |\n`;
              report += `|------------|------------|-------|----------|-------------|----------|---------------|\n`;
              
              for (const repo of repos) {
                const visibility = repo.private ? 'Private' : 'Public';
                const stars = repo.stargazers_count;
                const language = repo.language || 'N/A';
                const lastActivity = new Date(repo.last_activity_date).toLocaleDateString();
                const isArchived = repo.archived ? ' üì¶' : '';
                
                report += `| [${repo.name}](${repo.html_url})${isArchived} | ${visibility} | ${stars} | ${language} | ${repo.open_issues_count} | ${repo.open_prs_count} | ${lastActivity} |\n`;
              }
              report += `\n`;
            }
            
            console.log(`üíæ Saving report to file...`);
            // Save report
            const fs = require('fs');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-repository-overview-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            console.log(`‚úÖ Repository overview report saved as ${filename}`);
            console.log(`üìä Final Report Statistics:`);
            console.log(`  - Total repositories: ${enrichedRepos.length}`);
            console.log(`  - Repository types:`, Object.entries(typeBreakdown).map(([k,v]) => `${k}:${v}`).join(', '));
            console.log(`  - Total open issues: ${stats.totalOpenIssues}`);
            console.log(`  - Total open PRs: ${stats.totalOpenPRs}`);
            console.log(`  - Languages: ${stats.languages.length} (${stats.languages.slice(0, 5).join(', ')}${stats.languages.length > 5 ? '...' : ''})`);
            if (detailedActivity) {
              const significantDifferences = enrichedRepos.filter(r => {
                const timeDiff = Math.abs(r.last_activity_date - r.simple_activity_date) / (1000 * 60 * 60 * 24);
                return timeDiff > 1;
              });
              console.log(`  - Activity analysis differences: ${significantDifferences.length} repositories with >1 day difference`);
            }
            
            // Set output for artifact upload
            core.setOutput('report_filename', filename);
            
            console.log(`üìã Creating job summary...`);
            // Add to job summary (truncated version)
            const shortSummary = report.split('\n').slice(0, 80).join('\n') + '\n\n*Full report available in artifacts*';
            core.summary.addRaw(shortSummary);
            await core.summary.write();
            
            console.log(`üéâ Repository overview report generation completed successfully!`);
            console.log(`‚è±Ô∏è Report generation finished at: ${new Date().toISOString()}`);

      - name: Generate CAMARA API Releases Report
        if: github.event.inputs.report_type == 'api-releases'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            
            console.log(`üöÄ Starting CAMARA API releases report generation for ${org}`);
            console.log(`üìÖ Report generation started at: ${new Date().toISOString()}`);
            
            // Meta-release configuration based on CAMARA rules
            const commonalitiesMapping = {
              '0.4.0': 'Fall24',
              '0.5.0': 'Spring25', 
              '0.6.0': 'Fall25'
            };
            
            const metaReleaseDates = {
              'Fall24': new Date('2024-09-15'),
              'Spring25': new Date('2025-03-15'),
              'Fall25': new Date('2025-09-15')
            };
            
            console.log(`‚öôÔ∏è Meta-release configuration loaded:`, metaReleaseDates);
            
            // Helper function to add delay between API calls
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            // Helper function to retry API calls with exponential backoff
            async function retryApiCall(apiCall, maxRetries = 3, baseDelay = 1000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (attempt === maxRetries) {
                    throw error;
                  }
                  
                  const delayMs = baseDelay * Math.pow(2, attempt - 1);
                  console.log(`    ‚è≥ API call failed (attempt ${attempt}/${maxRetries}), retrying in ${delayMs}ms...`);
                  await delay(delayMs);
                }
              }
            }
            
            // Helper function to determine meta-release from repository release tag
            function determineMetaRelease(repoName, releaseTag, releaseDate) {
              const tagMatch = releaseTag.match(/^r(\d+)\.(\d+)$/);
              if (!tagMatch) return { cycle: 'Unknown', confidence: 'low', reason: 'Invalid tag format' };
              
              const major = parseInt(tagMatch[1]);
              const minor = parseInt(tagMatch[2]);
              const date = new Date(releaseDate);
              
              // Determine cycle based on major version and timing
              let estimatedCycle;
              if (major === 1) {
                estimatedCycle = date < metaReleaseDates.Fall24 ? 'Pre-Fall24' : 
                                date < metaReleaseDates.Spring25 ? 'Fall24' : 'Spring25';
              } else if (major === 2) {
                estimatedCycle = date < metaReleaseDates.Spring25 ? 'Spring25' : 'Fall25';
              } else if (major === 3) {
                estimatedCycle = 'Fall25';
              } else {
                estimatedCycle = 'Future';
              }
              
              const confidence = 'high';
              return { cycle: estimatedCycle, confidence, reason: `r${major}.x pattern + timing` };
            }
            
            // Helper function to read API definitions from repository
            async function getAPIDefinitions(repo, ref = 'main') {
              try {
                const definitionsPath = 'code/API_definitions';
                console.log(`  üìÇ Reading API definitions from ${repo.name}/${definitionsPath} @ ${ref}`);
                
                // Add small delay to avoid overwhelming the API
                await delay(200);
                
                // Get contents of API_definitions directory with retry
                const contents = await retryApiCall(async () => {
                  return await github.rest.repos.getContent({
                    owner: org,
                    repo: repo.name,
                    path: definitionsPath,
                    ref: ref
                  });
                });
                
                const yamlFiles = contents.data.filter(file => 
                  file.name.endsWith('.yaml') || file.name.endsWith('.yml')
                );
                
                console.log(`  üìÑ Found ${yamlFiles.length} YAML files in ${repo.name}: ${yamlFiles.map(f => f.name).join(', ')}`);
                
                const apiDefinitions = [];
                
                // Process YAML files with delays to avoid rate limiting
                for (let i = 0; i < yamlFiles.length; i++) {
                  const file = yamlFiles[i];
                  try {
                    console.log(`    üìñ Reading ${file.name} (${i + 1}/${yamlFiles.length})...`);
                    
                    // Add delay between file reads
                    if (i > 0) await delay(300);
                    
                    // Get the YAML content with retry
                    const fileContent = await retryApiCall(async () => {
                      return await github.rest.repos.getContent({
                        owner: org,
                        repo: repo.name,
                        path: file.path,
                        ref: ref
                      });
                    });
                    
                    const content = Buffer.from(fileContent.data.content, 'base64').toString('utf8');
                    
                    // Extract version using regex that handles YAML indentation  
                    // Look for 'version:' with optional leading whitespace (indentation)
                    const versionMatch = content.match(/^\s*version:\s*['"]?([^'"\s]+)['"]?$/m);
                    const version = versionMatch ? versionMatch[1] : 'Unknown';
                    
                    // Extract API name from filename
                    const apiName = file.name.replace(/\.(yaml|yml)$/, '');
                    
                    console.log(`    ‚úÖ ${apiName}: v${version}`);
                    
                    apiDefinitions.push({
                      name: apiName,
                      version: version,
                      filename: file.name,
                      path: file.path
                    });
                    
                  } catch (error) {
                    console.log(`    ‚ö†Ô∏è Could not read ${file.name} in ${repo.name} after retries: ${error.message}`);
                    // Continue processing other files even if one fails
                  }
                }
                
                console.log(`  ‚úÖ Successfully processed ${apiDefinitions.length} API definitions from ${repo.name}`);
                return apiDefinitions;
                
              } catch (error) {
                console.log(`  ‚ö†Ô∏è Could not access API definitions in ${repo.name} after retries: ${error.message}`);
                return [];
              }
            }
            
            console.log(`üîç Step 1: Fetching all repositories from ${org}...`);
            
            // Get all API repositories (sandbox or incubating)
            const allRepos = [];
            let page = 1;
            
            while (true) {
              console.log(`  üì• Fetching repositories page ${page}...`);
              const response = await github.rest.repos.listForOrg({
                org: org,
                type: 'all',
                sort: 'name',
                per_page: 100,
                page: page
              });
              
              if (response.data.length === 0) break;
              console.log(`  üìä Page ${page}: ${response.data.length} repositories`);
              allRepos.push(...response.data);
              page++;
            }
            
            console.log(`‚úÖ Step 1 Complete: Found ${allRepos.length} total repositories`);
            console.log(`üîç Step 2: Filtering for API repositories (sandbox/incubating topics)...`);
            
            // Filter for API repositories only
            const apiRepos = [];
            const nonArchivedRepos = allRepos.filter(r => !r.archived);
            console.log(`üìä Processing ${nonArchivedRepos.length} non-archived repositories...`);
            
            for (let i = 0; i < nonArchivedRepos.length; i++) {
              const repo = nonArchivedRepos[i];
              console.log(`  üè∑Ô∏è Checking topics for ${repo.name} (${i + 1}/${nonArchivedRepos.length})`);
              
              try {
                // Add small delay to avoid rate limiting
                if (i > 0 && i % 10 === 0) {
                  console.log(`    ‚è∏Ô∏è Taking a short break after ${i} repositories...`);
                  await delay(2000);
                }
                
                const topics = await retryApiCall(async () => {
                  return await github.rest.repos.getAllTopics({
                    owner: org,
                    repo: repo.name
                  });
                });
                
                const hasAPITopic = topics.data.names.some(topic => 
                  topic === 'sandbox-api-repository' || topic === 'incubating-api-repository'
                );
                
                if (hasAPITopic) {
                  const repoType = topics.data.names.includes('sandbox-api-repository') ? 'Sandbox' : 'Incubating';
                  console.log(`  ‚úÖ ${repo.name}: ${repoType} API repository`);
                  apiRepos.push({
                    ...repo,
                    repo_type: repoType,
                    topics: topics.data.names
                  });
                } else {
                  console.log(`  ‚è≠Ô∏è ${repo.name}: Not an API repository (topics: ${topics.data.names.join(', ') || 'none'})`);
                }
              } catch (error) {
                console.log(`  ‚ö†Ô∏è Could not get topics for ${repo.name} after retries: ${error.message}`);
              }
              
              // Small delay between repositories
              await delay(100);
            }
            
            console.log(`‚úÖ Step 2 Complete: Found ${apiRepos.length} API repositories`);
            console.log(`üìã API Repository Summary:`);
            const sandboxCount = apiRepos.filter(r => r.repo_type === 'Sandbox').length;
            const incubatingCount = apiRepos.filter(r => r.repo_type === 'Incubating').length;
            console.log(`  - Sandbox: ${sandboxCount}`);
            console.log(`  - Incubating: ${incubatingCount}`);
            
            console.log(`üîç Step 3: Analyzing releases for each API repository...`);
            
            // Analyze releases for each API repository
            const repoAnalysis = [];
            const reposWithoutReleases = [];
            
            for (let i = 0; i < apiRepos.length; i++) {
              const repo = apiRepos[i];
              console.log(`\nüì¶ [${i + 1}/${apiRepos.length}] Analyzing ${repo.name} (${repo.repo_type})...`);
              
              // Add longer delays between repositories to avoid overwhelming the API
              if (i > 0) {
                console.log(`  ‚è∏Ô∏è Brief pause before processing next repository...`);
                await delay(1000);
              }
              
              try {
                console.log(`  üè∑Ô∏è Fetching releases...`);
                // Get releases with retry
                const releases = await retryApiCall(async () => {
                  return await github.rest.repos.listReleases({
                    owner: org,
                    repo: repo.name,
                    per_page: 20
                  });
                });
                
                console.log(`  üìä Found ${releases.data.length} releases`);
                
                if (releases.data.length === 0) {
                  console.log(`  ‚ö†Ô∏è No releases found - checking main branch API definitions`);
                  // Repository without releases - get main branch API definitions
                  const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                  reposWithoutReleases.push({
                    name: repo.name,
                    repo_type: repo.repo_type,
                    html_url: repo.html_url,
                    api_definitions: mainBranchAPIs
                  });
                  console.log(`  ‚úÖ Added ${repo.name} to repositories without releases`);
                  continue;
                }
                
                console.log(`  üîç Analyzing ${releases.data.length} releases...`);
                // Analyze each release
                const releaseAnalysis = [];
                for (let j = 0; j < releases.data.length; j++) {
                  const release = releases.data[j];
                  console.log(`    üìã [${j + 1}/${releases.data.length}] Processing release ${release.tag_name} (${new Date(release.published_at).toDateString()})`);
                  
                  const metaRelease = determineMetaRelease(repo.name, release.tag_name, release.published_at);
                  console.log(`    üéØ Meta-release: ${metaRelease.cycle} (${metaRelease.confidence} confidence)`);
                  
                  // Get API definitions for this release
                  const apiDefinitions = await getAPIDefinitions(repo, release.tag_name);
                  
                  releaseAnalysis.push({
                    tag_name: release.tag_name,
                    name: release.name,
                    published_at: release.published_at,
                    prerelease: release.prerelease,
                    html_url: release.html_url,
                    body: release.body,
                    meta_release: metaRelease,
                    api_definitions: apiDefinitions
                  });
                  
                  // Small delay between releases
                  if (j < releases.data.length - 1) await delay(500);
                }
                
                console.log(`  üìÇ Getting main branch API definitions for comparison...`);
                // Get main branch API definitions for comparison
                const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                
                repoAnalysis.push({
                  name: repo.name,
                  repo_type: repo.repo_type,
                  html_url: repo.html_url,
                  releases: releaseAnalysis,
                  main_branch_apis: mainBranchAPIs
                });
                
                console.log(`  ‚úÖ Completed analysis for ${repo.name}`);
                
              } catch (error) {
                console.log(`  ‚ùå Error analyzing ${repo.name} after retries: ${error.message}`);
                // Continue with next repository even if this one fails
              }
            }
            
            console.log(`\n‚úÖ Step 3 Complete: Repository Analysis Summary`);
            console.log(`  - Repositories with releases: ${repoAnalysis.length}`);
            console.log(`  - Repositories without releases: ${reposWithoutReleases.length}`);
            
            console.log(`\nüîç Step 4: Generating comprehensive report...`);
            
            // Generate comprehensive report
            let report = `# CAMARA API Releases Report\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**API Repositories Analyzed**: ${apiRepos.length}\n`;
            report += `**Repositories with Releases**: ${repoAnalysis.length}\n`;
            report += `**Repositories without Releases**: ${reposWithoutReleases.length}\n\n`;
            
            console.log(`üìä Calculating meta-release summary...`);
            // Meta-release summary
            const metaReleaseCounts = {};
            repoAnalysis.forEach(repo => {
              repo.releases.forEach(release => {
                const cycle = release.meta_release.cycle;
                metaReleaseCounts[cycle] = (metaReleaseCounts[cycle] || 0) + 1;
              });
            });
            
            console.log(`üìà Meta-release counts:`, metaReleaseCounts);
            
            report += `## Meta-Release Summary\n\n`;
            Object.entries(metaReleaseCounts).sort().forEach(([cycle, count]) => {
              report += `- **${cycle}**: ${count} releases\n`;
            });
            report += `\n`;
            
            console.log(`üìÖ Calculating recent releases (last 30 days)...`);
            // Recent releases across all repos (last 30 days)
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const recentReleases = [];
            
            repoAnalysis.forEach(repo => {
              repo.releases.forEach(release => {
                if (new Date(release.published_at) > thirtyDaysAgo) {
                  recentReleases.push({
                    repo: repo.name,
                    repo_type: repo.repo_type,
                    repo_url: repo.html_url,
                    ...release
                  });
                }
              });
            });
            
            console.log(`üìà Found ${recentReleases.length} recent releases`);
            
            if (recentReleases.length > 0) {
              report += `## Recent Releases (Last 30 Days)\n\n`;
              report += `| Repository | Type | Release | Version | APIs | Date | Meta-Release |\n`;
              report += `|------------|------|---------|---------|------|------|-------------|\n`;
              
              recentReleases.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
              
              for (const release of recentReleases) {
                const date = new Date(release.published_at).toLocaleDateString();
                const name = release.name || release.tag_name;
                const apiList = release.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                const metaRelease = `${release.meta_release.cycle} (${release.meta_release.confidence})`;
                
                report += `| [${release.repo}](${release.repo_url}) | ${release.repo_type} | [${name}](${release.html_url}) | ${release.tag_name} | ${apiList} | ${date} | ${metaRelease} |\n`;
              }
              report += `\n`;
            }
            
            console.log(`üîç Running consistency analysis...`);
            // Consistency check section
            report += `## Consistency Analysis\n\n`;
            
            const consistencyIssues = [];
            
            for (const repo of repoAnalysis) {
              const latestRelease = repo.releases[0]; // Most recent release
              
              // Check 1: Main branch API versions should be latest release or "wip"
              for (const mainAPI of repo.main_branch_apis) {
                const correspondingReleaseAPI = latestRelease?.api_definitions.find(api => api.name === mainAPI.name);
                
                if (correspondingReleaseAPI) {
                  if (mainAPI.version !== correspondingReleaseAPI.version && mainAPI.version !== 'wip') {
                    consistencyIssues.push({
                      repo: repo.name,
                      type: 'Version Mismatch',
                      description: `${mainAPI.name}: main branch v${mainAPI.version} ‚â† latest release v${correspondingReleaseAPI.version} (should be same or "wip")`
                    });
                  }
                }
              }
              
              // Check 2: Release descriptions should mention API versions
              for (const release of repo.releases.slice(0, 3)) { // Check latest 3 releases
                for (const api of release.api_definitions) {
                  if (!release.body.includes(api.version)) {
                    consistencyIssues.push({
                      repo: repo.name,
                      type: 'Missing Version in Description',
                      description: `${release.tag_name}: API ${api.name} v${api.version} not mentioned in release description`
                    });
                  }
                }
              }
            }
            
            console.log(`üìã Found ${consistencyIssues.length} consistency issues`);
            
            if (consistencyIssues.length > 0) {
              report += `### Consistency Issues Found\n\n`;
              report += `| Repository | Issue Type | Description |\n`;
              report += `|------------|------------|-------------|\n`;
              
              for (const issue of consistencyIssues.slice(0, 20)) { // Limit to first 20
                report += `| ${issue.repo} | ${issue.type} | ${issue.description} |\n`;
              }
              
              if (consistencyIssues.length > 20) {
                report += `\n*Showing first 20 of ${consistencyIssues.length} issues*\n`;
              }
              report += `\n`;
            } else {
              report += `‚úÖ No consistency issues found!\n\n`;
            }
            
            console.log(`üìù Building detailed repository analysis section...`);
            // Detailed repository analysis
            report += `## Detailed Repository Analysis\n\n`;
            
            for (const repo of repoAnalysis.sort((a, b) => a.name.localeCompare(b.name))) {
              report += `### [${repo.name}](${repo.html_url}) (${repo.repo_type})\n\n`;
              
              // Current main branch APIs
              if (repo.main_branch_apis.length > 0) {
                report += `**Main Branch APIs:**\n`;
                for (const api of repo.main_branch_apis) {
                  report += `- ${api.name}: v${api.version}\n`;
                }
                report += `\n`;
              }
              
              // Release history
              report += `**Release History:**\n`;
              report += `| Release | Date | Type | Meta-Release | APIs |\n`;
              report += `|---------|------|------|--------------|------|\n`;
              
              for (const release of repo.releases.slice(0, 5)) { // Latest 5 releases
                const date = new Date(release.published_at).toLocaleDateString();
                const type = release.prerelease ? 'Pre-release' : 'Release';
                const metaRelease = `${release.meta_release.cycle}`;
                const apiList = release.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                
                report += `| [${release.tag_name}](${release.html_url}) | ${date} | ${type} | ${metaRelease} | ${apiList} |\n`;
              }
              report += `\n`;
            }
            
            console.log(`üìù Adding repositories without releases section...`);
            // Repositories without releases
            if (reposWithoutReleases.length > 0) {
              report += `## API Repositories Without Releases\n\n`;
              report += `| Repository | Type | API Definitions Found |\n`;
              report += `|------------|------|-----------------------|\n`;
              
              for (const repo of reposWithoutReleases.sort((a, b) => a.name.localeCompare(b.name))) {
                const apiList = repo.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                
                report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${apiList} |\n`;
              }
              report += `\n`;
            }
            
            console.log(`üíæ Saving report to file...`);
            // Save report
            const fs = require('fs');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-api-releases-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            console.log(`‚úÖ Enhanced API releases report saved as ${filename}`);
            console.log(`üìä Final Report Statistics:`);
            console.log(`  - Total API repositories: ${apiRepos.length}`);
            console.log(`  - Repositories with releases: ${repoAnalysis.length}`);
            console.log(`  - Repositories without releases: ${reposWithoutReleases.length}`);
            console.log(`  - Recent releases (30 days): ${recentReleases.length}`);
            console.log(`  - Consistency issues found: ${consistencyIssues.length}`);
            console.log(`  - Meta-release distribution:`, Object.entries(metaReleaseCounts).map(([k,v]) => `${k}:${v}`).join(', '));
            
            core.setOutput('report_filename', filename);
            
            console.log(`üìã Creating job summary...`);
            // Add to job summary
            const shortSummary = report.split('\n').slice(0, 50).join('\n') + '\n\n*Full detailed report available in artifacts*';
            core.summary.addRaw(shortSummary);
            await core.summary.write();
            
            console.log(`üéâ CAMARA API releases report generation completed successfully!`);
            console.log(`‚è±Ô∏è Report generation finished at: ${new Date().toISOString()}`);


      - name: Generate Security Analysis Report
        if: github.event.inputs.report_type == 'security-analysis'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            
            console.log(`üöÄ Starting security analysis report for ${org}`);
            console.log(`üìÖ Report generation started at: ${new Date().toISOString()}`);
            
            // This is a basic implementation - you might want to enhance it
            let report = `# CAMARA Project Security Analysis\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**Note**: This is a basic security analysis report. `;
            report += `For detailed security analysis, consider using GitHub's Security API.\n\n`;
            
            report += `## Security Analysis\n\n`;
            report += `To get detailed security analysis:\n`;
            report += `1. Use GitHub's REST API to fetch security alerts\n`;
            report += `2. Analyze dependency vulnerabilities\n`;
            report += `3. Check for security policies and workflows\n`;
            report += `4. Generate alerts for critical security issues\n\n`;
            
            report += `This report type can be enhanced with specific security monitoring requirements.\n`;
            
            console.log(`üíæ Saving basic security analysis report...`);
            // Save report
            const fs = require('fs');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-security-analysis-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            console.log(`‚úÖ Security analysis report saved as ${filename}`);
            core.setOutput('report_filename', filename);
            
            core.summary.addRaw(report);
            await core.summary.write();
            
            console.log(`üéâ Security analysis report generation completed!`);

  analyze-api-repositories:
    if: github.event.inputs.report_type == 'api-releases'
    needs: [generate-report]
    strategy:
      matrix:
        group: ${{ fromJson(needs.generate-report.outputs.repository_groups) }}
      fail-fast: false
      max-parallel: 6  # Process up to 6 groups simultaneously
    runs-on: ubuntu-latest
    outputs:
      analysis_result: ${{ steps.analyze-group.outputs.result }}
    steps:
      - name: Analyze Repository Group
        id: analyze-group
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            const groupId = ${{ matrix.group.id }};
            const repositories = ${{ toJson(matrix.group.repositories) }};
            
            console.log(`üöÄ Starting analysis for Group ${groupId}`);
            console.log(`üì¶ Processing ${repositories.length} repositories: ${repositories.map(r => r.name).join(', ')}`);
            
            // Meta-release configuration
            const metaReleaseDates = {
              'Fall24': new Date('2024-09-15'),
              'Spring25': new Date('2025-03-15'),
              'Fall25': new Date('2025-09-15')
            };
            
            // Helper functions (same as before but with better error handling)
            function delay(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            async function retryApiCall(apiCall, maxRetries = 3, baseDelay = 1000) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  return await apiCall();
                } catch (error) {
                  if (attempt === maxRetries) {
                    throw error;
                  }
                  
                  const delayMs = baseDelay * Math.pow(2, attempt - 1);
                  console.log(`    ‚è≥ API call failed (attempt ${attempt}/${maxRetries}), retrying in ${delayMs}ms...`);
                  await delay(delayMs);
                }
              }
            }
            
            function determineMetaRelease(repoName, releaseTag, releaseDate) {
              const tagMatch = releaseTag.match(/^r(\d+)\.(\d+)$/);
              if (!tagMatch) return { cycle: 'Unknown', confidence: 'low', reason: 'Invalid tag format' };
              
              const major = parseInt(tagMatch[1]);
              const date = new Date(releaseDate);
              
              let estimatedCycle;
              if (major === 1) {
                estimatedCycle = date < metaReleaseDates.Fall24 ? 'Pre-Fall24' : 
                                date < metaReleaseDates.Spring25 ? 'Fall24' : 'Spring25';
              } else if (major === 2) {
                estimatedCycle = date < metaReleaseDates.Spring25 ? 'Spring25' : 'Fall25';
              } else if (major === 3) {
                estimatedCycle = 'Fall25';
              } else {
                estimatedCycle = 'Future';
              }
              
              return { cycle: estimatedCycle, confidence: 'high', reason: `r${major}.x pattern + timing` };
            }
            
            async function getAPIDefinitions(repo, ref = 'main') {
              try {
                const definitionsPath = 'code/API_definitions';
                console.log(`    üìÇ Reading API definitions from ${repo.name}/${definitionsPath} @ ${ref}`);
                
                await delay(200);
                
                const contents = await retryApiCall(async () => {
                  return await github.rest.repos.getContent({
                    owner: org,
                    repo: repo.name,
                    path: definitionsPath,
                    ref: ref
                  });
                });
                
                const yamlFiles = contents.data.filter(file => 
                  file.name.endsWith('.yaml') || file.name.endsWith('.yml')
                );
                
                console.log(`    üìÑ Found ${yamlFiles.length} YAML files: ${yamlFiles.map(f => f.name).join(', ')}`);
                
                const apiDefinitions = [];
                
                for (let i = 0; i < yamlFiles.length; i++) {
                  const file = yamlFiles[i];
                  try {
                    if (i > 0) await delay(300);
                    
                    const fileContent = await retryApiCall(async () => {
                      return await github.rest.repos.getContent({
                        owner: org,
                        repo: repo.name,
                        path: file.path,
                        ref: ref
                      });
                    });
                    
                    const content = Buffer.from(fileContent.data.content, 'base64').toString('utf8');
                    
                    // Extract version using regex that handles YAML indentation
                    // Look for 'version:' with optional leading whitespace (indentation) 
                    const versionMatch = content.match(/^\s*version:\s*['"]?([^'"\s]+)['"]?$/m);
                    const version = versionMatch ? versionMatch[1] : 'Unknown';
                    const apiName = file.name.replace(/\.(yaml|yml)$/, '');
                    
                    console.log(`      ‚úÖ ${apiName}: v${version}`);
                    
                    apiDefinitions.push({
                      name: apiName,
                      version: version,
                      filename: file.name,
                      path: file.path
                    });
                  } catch (error) {
                    console.log(`      ‚ö†Ô∏è Could not read ${file.name}: ${error.message}`);
                  }
                }
                
                return apiDefinitions;
              } catch (error) {
                console.log(`    ‚ö†Ô∏è Could not access API definitions in ${repo.name}: ${error.message}`);
                return [];
              }
            }
            
            // Process repositories in this group
            const groupResults = {
              groupId: groupId,
              repositories: [],
              repositoriesWithoutReleases: [],
              processingErrors: []
            };
            
            for (let i = 0; i < repositories.length; i++) {
              const repo = repositories[i];
              console.log(`\nüì¶ [${i + 1}/${repositories.length}] Analyzing ${repo.name} (${repo.repo_type})...`);
              
              if (i > 0) await delay(800); // Longer delays since we have more time per group
              
              try {
                // Get releases
                const releases = await retryApiCall(async () => {
                  return await github.rest.repos.listReleases({
                    owner: org,
                    repo: repo.name,
                    per_page: 20
                  });
                });
                
                console.log(`  üìä Found ${releases.data.length} releases`);
                
                if (releases.data.length === 0) {
                  console.log(`  ‚ö†Ô∏è No releases - checking main branch`);
                  const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                  groupResults.repositoriesWithoutReleases.push({
                    name: repo.name,
                    repo_type: repo.repo_type,
                    html_url: repo.html_url,
                    api_definitions: mainBranchAPIs
                  });
                  continue;
                }
                
                // Analyze releases
                const releaseAnalysis = [];
                for (let j = 0; j < releases.data.length; j++) {
                  const release = releases.data[j];
                  console.log(`    üìã Processing release ${release.tag_name}`);
                  
                  const metaRelease = determineMetaRelease(repo.name, release.tag_name, release.published_at);
                  const apiDefinitions = await getAPIDefinitions(repo, release.tag_name);
                  
                  releaseAnalysis.push({
                    tag_name: release.tag_name,
                    name: release.name,
                    published_at: release.published_at,
                    prerelease: release.prerelease,
                    html_url: release.html_url,
                    body: release.body,
                    meta_release: metaRelease,
                    api_definitions: apiDefinitions
                  });
                  
                  if (j < releases.data.length - 1) await delay(400);
                }
                
                // Get main branch APIs
                const mainBranchAPIs = await getAPIDefinitions(repo, 'main');
                
                groupResults.repositories.push({
                  name: repo.name,
                  repo_type: repo.repo_type,
                  html_url: repo.html_url,
                  releases: releaseAnalysis,
                  main_branch_apis: mainBranchAPIs
                });
                
                console.log(`  ‚úÖ Completed ${repo.name}`);
                
              } catch (error) {
                console.log(`  ‚ùå Error analyzing ${repo.name}: ${error.message}`);
                groupResults.processingErrors.push({
                  repository: repo.name,
                  error: error.message
                });
              }
            }
            
            console.log(`\n‚úÖ Group ${groupId} completed:`);
            console.log(`  - Repositories processed: ${groupResults.repositories.length}`);
            console.log(`  - Repositories without releases: ${groupResults.repositoriesWithoutReleases.length}`);
            console.log(`  - Processing errors: ${groupResults.processingErrors.length}`);
            
            // Save group results as artifact
            const fs = require('fs');
            const groupResultsFile = `group-${groupId}-results.json`;
            fs.writeFileSync(groupResultsFile, JSON.stringify(groupResults, null, 2));
            
            core.setOutput('result', JSON.stringify(groupResults));
            
            return groupResults;

      - name: Upload Group Results
        uses: actions/upload-artifact@v4
        with:
          name: api-analysis-group-${{ matrix.group.id }}
          path: '*.json'
          retention-days: 1  # Short retention since we'll combine them

  combine-api-analysis:
    if: github.event.inputs.report_type == 'api-releases'
    needs: [generate-report, analyze-api-repositories]
    runs-on: ubuntu-latest
    steps:
      - name: Download All Group Results
        uses: actions/download-artifact@v4
        with:
          pattern: api-analysis-group-*
          merge-multiple: true
          path: group-results

      - name: Combine Results and Generate Report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            console.log(`üîÑ Combining results from parallel analysis...`);
            
            // Read all group result files
            const groupResultsDir = 'group-results';
            const files = fs.readdirSync(groupResultsDir);
            const groupFiles = files.filter(f => f.startsWith('group-') && f.endsWith('-results.json'));
            
            console.log(`üìÅ Found ${groupFiles.length} group result files`);
            
            let allRepositories = [];
            let allRepositoriesWithoutReleases = [];
            let allProcessingErrors = [];
            
            // Combine all group results
            for (const file of groupFiles) {
              const filePath = path.join(groupResultsDir, file);
              const groupData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
              
              console.log(`üìä Group ${groupData.groupId}: ${groupData.repositories.length} repos processed`);
              
              allRepositories = allRepositories.concat(groupData.repositories);
              allRepositoriesWithoutReleases = allRepositoriesWithoutReleases.concat(groupData.repositoriesWithoutReleases);
              allProcessingErrors = allProcessingErrors.concat(groupData.processingErrors);
            }
            
            console.log(`‚úÖ Combined results:`);
            console.log(`  - Total repositories with releases: ${allRepositories.length}`);
            console.log(`  - Total repositories without releases: ${allRepositoriesWithoutReleases.length}`);
            console.log(`  - Total processing errors: ${allProcessingErrors.length}`);
            
            // Generate comprehensive report (same logic as before but with combined data)
            let report = `# CAMARA API Releases Report (Parallel Analysis)\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**Processing Method**: Parallel Matrix Analysis\n`;
            report += `**API Repositories Analyzed**: ${allRepositories.length + allRepositoriesWithoutReleases.length}\n`;
            report += `**Repositories with Releases**: ${allRepositories.length}\n`;
            report += `**Repositories without Releases**: ${allRepositoriesWithoutReleases.length}\n`;
            if (allProcessingErrors.length > 0) {
              report += `**Processing Errors**: ${allProcessingErrors.length}\n`;
            }
            report += `\n`;
            
            // Meta-release summary
            const metaReleaseCounts = {};
            allRepositories.forEach(repo => {
              repo.releases.forEach(release => {
                const cycle = release.meta_release.cycle;
                metaReleaseCounts[cycle] = (metaReleaseCounts[cycle] || 0) + 1;
              });
            });
            
            report += `## Meta-Release Summary\n\n`;
            Object.entries(metaReleaseCounts).sort().forEach(([cycle, count]) => {
              report += `- **${cycle}**: ${count} releases\n`;
            });
            report += `\n`;
            
            // Recent releases (last 30 days)
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const recentReleases = [];
            
            allRepositories.forEach(repo => {
              repo.releases.forEach(release => {
                if (new Date(release.published_at) > thirtyDaysAgo) {
                  recentReleases.push({
                    repo: repo.name,
                    repo_type: repo.repo_type,
                    repo_url: repo.html_url,
                    ...release
                  });
                }
              });
            });
            
            if (recentReleases.length > 0) {
              report += `## Recent Releases (Last 30 Days)\n\n`;
              report += `| Repository | Type | Release | Version | APIs | Date | Meta-Release |\n`;
              report += `|------------|------|---------|---------|------|------|-------------|\n`;
              
              recentReleases.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
              
              for (const release of recentReleases) {
                const date = new Date(release.published_at).toLocaleDateString();
                const name = release.name || release.tag_name;
                const apiList = release.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                const metaRelease = `${release.meta_release.cycle} (${release.meta_release.confidence})`;
                
                report += `| [${release.repo}](${release.repo_url}) | ${release.repo_type} | [${name}](${release.html_url}) | ${release.tag_name} | ${apiList} | ${date} | ${metaRelease} |\n`;
              }
              report += `\n`;
            }
            
            // Consistency analysis
            report += `## Consistency Analysis\n\n`;
            
            const consistencyIssues = [];
            
            for (const repo of allRepositories) {
              const latestRelease = repo.releases[0];
              
              // Check main branch vs latest release
              for (const mainAPI of repo.main_branch_apis) {
                const correspondingReleaseAPI = latestRelease?.api_definitions.find(api => api.name === mainAPI.name);
                
                if (correspondingReleaseAPI) {
                  if (mainAPI.version !== correspondingReleaseAPI.version && mainAPI.version !== 'wip') {
                    consistencyIssues.push({
                      repo: repo.name,
                      type: 'Version Mismatch',
                      description: `${mainAPI.name}: main branch v${mainAPI.version} ‚â† latest release v${correspondingReleaseAPI.version} (should be same or "wip")`
                    });
                  }
                }
              }
              
              // Check release descriptions
              for (const release of repo.releases.slice(0, 3)) {
                for (const api of release.api_definitions) {
                  if (!release.body.includes(api.version)) {
                    consistencyIssues.push({
                      repo: repo.name,
                      type: 'Missing Version in Description',
                      description: `${release.tag_name}: API ${api.name} v${api.version} not mentioned in release description`
                    });
                  }
                }
              }
            }
            
            if (consistencyIssues.length > 0) {
              report += `### Consistency Issues Found\n\n`;
              report += `| Repository | Issue Type | Description |\n`;
              report += `|------------|------------|-------------|\n`;
              
              for (const issue of consistencyIssues.slice(0, 20)) {
                report += `| ${issue.repo} | ${issue.type} | ${issue.description} |\n`;
              }
              
              if (consistencyIssues.length > 20) {
                report += `\n*Showing first 20 of ${consistencyIssues.length} issues*\n`;
              }
              report += `\n`;
            } else {
              report += `‚úÖ No consistency issues found!\n\n`;
            }
            
            // Processing errors section
            if (allProcessingErrors.length > 0) {
              report += `## Processing Errors\n\n`;
              report += `The following repositories encountered errors during analysis:\n\n`;
              report += `| Repository | Error |\n`;
              report += `|------------|-------|\n`;
              
              for (const error of allProcessingErrors) {
                report += `| ${error.repository} | ${error.error} |\n`;
              }
              report += `\n`;
            }
            
            // Detailed repository analysis
            report += `## Detailed Repository Analysis\n\n`;
            
            for (const repo of allRepositories.sort((a, b) => a.name.localeCompare(b.name))) {
              report += `### [${repo.name}](${repo.html_url}) (${repo.repo_type})\n\n`;
              
              if (repo.main_branch_apis.length > 0) {
                report += `**Main Branch APIs:**\n`;
                for (const api of repo.main_branch_apis) {
                  report += `- ${api.name}: v${api.version}\n`;
                }
                report += `\n`;
              }
              
              report += `**Release History:**\n`;
              report += `| Release | Date | Type | Meta-Release | APIs |\n`;
              report += `|---------|------|------|--------------|------|\n`;
              
              for (const release of repo.releases.slice(0, 5)) {
                const date = new Date(release.published_at).toLocaleDateString();
                const type = release.prerelease ? 'Pre-release' : 'Release';
                const metaRelease = `${release.meta_release.cycle}`;
                const apiList = release.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                
                report += `| [${release.tag_name}](${release.html_url}) | ${date} | ${type} | ${metaRelease} | ${apiList} |\n`;
              }
              report += `\n`;
            }
            
            // Repositories without releases
            if (allRepositoriesWithoutReleases.length > 0) {
              report += `## API Repositories Without Releases\n\n`;
              report += `| Repository | Type | API Definitions Found |\n`;
              report += `|------------|------|-----------------------|\n`;
              
              for (const repo of allRepositoriesWithoutReleases.sort((a, b) => a.name.localeCompare(b.name))) {
                const apiList = repo.api_definitions.map(api => `${api.name} v${api.version}`).join('<br>');
                
                report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${apiList} |\n`;
              }
              report += `\n`;
            }
            
            // Save final report
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-api-releases-parallel-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            console.log(`‚úÖ Parallel API releases report saved as ${filename}`);
            console.log(`üìä Final Statistics:`);
            console.log(`  - Processing time: ~3-5 minutes (vs 15-20 minutes sequential)`);
            console.log(`  - Repositories analyzed: ${allRepositories.length + allRepositoriesWithoutReleases.length}`);
            console.log(`  - Recent releases found: ${recentReleases.length}`);
            console.log(`  - Consistency issues: ${consistencyIssues.length}`);
            console.log(`  - Processing errors: ${allProcessingErrors.length}`);
            
            core.setOutput('report_filename', filename);
            
            // Create job summary
            const shortSummary = report.split('\n').slice(0, 50).join('\n') + '\n\n*Full detailed report available in artifacts*';
            core.summary.addRaw(shortSummary);
            await core.summary.write();
            
            console.log(`üéâ Parallel CAMARA API releases report generation completed!`);

      - name: Upload Final Parallel Report
        uses: actions/upload-artifact@v4
        with:
          name: camara-api-releases-parallel-report
          path: '*.md'
          retention-days: 90

      - name: Upload Report Artifact
        if: github.event.inputs.report_type != 'api-releases'
        uses: actions/upload-artifact@v4
        with:
          name: camara-project-report-${{ github.event.inputs.report_type || 'repository-overview' }}-${{ github.run_number }}
          path: '*.md'
          retention-days: 90

  final-summary:
    if: always()
    needs: [generate-report]
    runs-on: ubuntu-latest
    steps:
      - name: Final Summary
        run: |
          # Determine the status of the main job
          GENERATE_STATUS="${{ needs.generate-report.result }}"
          
          echo "üéâ Report Generation Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Report Type**: ${{ github.event.inputs.report_type || 'repository-overview' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Generated At**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Job Status**: ${GENERATE_STATUS}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ github.event.inputs.report_type }}" = "api-releases" ]; then
            echo "**Processing Method**: Parallel Matrix Analysis" >> $GITHUB_STEP_SUMMARY
            echo "**Note**: API releases use multi-job parallel processing" >> $GITHUB_STEP_SUMMARY
            echo "**Download**: Check artifacts in the final analysis job" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Download**: Check the artifacts section of this workflow run" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "‚úÖ CAMARA project report generation workflow completed"
          echo "üìä Report type: ${{ github.event.inputs.report_type || 'repository-overview' }}"
          echo "üìÖ Completed at: $(date -u)"
          echo "üìã Status: ${GENERATE_STATUS}"
          
          if [ "${{ github.event.inputs.report_type }}" = "api-releases" ]; then
            echo "‚ö° Used parallel processing for faster API analysis"
          fi
          
          echo "üìÅ Artifact uploaded and available for download"

name: Generate CAMARA Project Reports

on:
  workflow_dispatch:
    inputs:
      report_type:
        description: 'Type of report to generate'
        required: true
        type: choice
        options:
          - 'repository-overview'
          - 'workflow-status'
          - 'api-releases'
          - 'security-analysis'
        default: 'repository-overview'
      
      include_archived:
        description: 'Include archived repositories'
        required: false
        type: boolean
        default: false
      
      detailed_activity:
        description: 'Include detailed activity analysis (slower but more accurate)'
        required: false
        type: boolean
        default: false

  schedule:
    # Run weekly on Mondays at 07:35 UTC
    - cron: '35 7 * * 1'

jobs:
  generate-report:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate Repository Overview Report
        if: github.event.inputs.report_type == 'repository-overview' || github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            const includeArchived = '${{ github.event.inputs.include_archived }}' === 'true';
            const detailedActivity = '${{ github.event.inputs.detailed_activity }}' === 'true';
            
            console.log(`Generating repository overview for ${org}`);
            console.log(`Include archived: ${includeArchived}`);
            console.log(`Detailed activity analysis: ${detailedActivity}`);
            
            // Helper function to determine repository type based on topics
            function getRepositoryType(topics) {
              if (topics.includes('sandbox-api-repository')) return 'Sandbox';
              if (topics.includes('incubating-api-repository')) return 'Incubating';
              if (topics.includes('workinggroup')) return 'Working Group';
              return 'Other';
            }
            
            // Helper function to get last activity date from multiple sources (only used if detailedActivity is true)
            async function getLastActivityDate(repo) {
              let lastActivity = new Date(repo.updated_at);
              let activityLink = repo.html_url;
              let activityType = 'repository';
              
              try {
                // Check recent commits
                const commits = await github.rest.repos.listCommits({
                  owner: org,
                  repo: repo.name,
                  per_page: 1
                });
                if (commits.data.length > 0) {
                  const commitDate = new Date(commits.data[0].commit.committer.date);
                  if (commitDate > lastActivity) {
                    lastActivity = commitDate;
                    activityLink = commits.data[0].html_url;
                    activityType = 'commit';
                  }
                }
                
                // Check recent issues
                const issues = await github.rest.issues.listForRepo({
                  owner: org,
                  repo: repo.name,
                  state: 'all',
                  sort: 'updated',
                  per_page: 1
                });
                if (issues.data.length > 0) {
                  const issueDate = new Date(issues.data[0].updated_at);
                  if (issueDate > lastActivity) {
                    lastActivity = issueDate;
                    activityLink = issues.data[0].html_url;
                    activityType = issues.data[0].pull_request ? 'pull_request' : 'issue';
                  }
                }
                
                // Check recent pull requests (in case issues API missed some)
                const prs = await github.rest.pulls.list({
                  owner: org,
                  repo: repo.name,
                  state: 'all',
                  sort: 'updated',
                  per_page: 1
                });
                if (prs.data.length > 0) {
                  const prDate = new Date(prs.data[0].updated_at);
                  if (prDate > lastActivity) {
                    lastActivity = prDate;
                    activityLink = prs.data[0].html_url;
                    activityType = 'pull_request';
                  }
                }
              } catch (error) {
                console.log(`Could not get detailed activity for ${repo.name}: ${error.message}`);
              }
              
              return {
                date: lastActivity,
                link: activityLink,
                type: activityType
              };
            }
            
            // Get all repositories
            let allRepos = [];
            let page = 1;
            
            while (true) {
              const response = await github.rest.repos.listForOrg({
                org: org,
                type: 'all',
                sort: 'name',
                per_page: 100,
                page: page
              });
              
              if (response.data.length === 0) break;
              allRepos = allRepos.concat(response.data);
              page++;
            }
            
            // Filter repositories
            const filteredRepos = includeArchived ? allRepos : allRepos.filter(r => !r.archived);
            
            console.log(`Processing ${filteredRepos.length} repositories for information...`);
            if (detailedActivity) {
              console.log('⚠️ Detailed activity analysis enabled - this will take longer but provide more accurate activity dates');
            }
            
            // Enrich repository data with additional information
            const enrichedRepos = [];
            for (let i = 0; i < filteredRepos.length; i++) {
              const repo = filteredRepos[i];
              console.log(`Processing ${i + 1}/${filteredRepos.length}: ${repo.name}`);
              
              try {
                // Get repository topics
                const topics = await github.rest.repos.getAllTopics({
                  owner: org,
                  repo: repo.name
                });
                
                // Get open issues and PRs count (avoiding deprecated search API)
                const openPRs = await github.rest.pulls.list({
                  owner: org,
                  repo: repo.name,
                  state: 'open',
                  per_page: 100
                }).then(async (response) => {
                  let total = response.data.length;
                  
                  // If we got 100 results, there might be more - paginate
                  if (response.data.length === 100) {
                    let page = 2;
                    while (true) {
                      const nextPage = await github.rest.pulls.list({
                        owner: org,
                        repo: repo.name,
                        state: 'open',
                        per_page: 100,
                        page: page
                      });
                      
                      if (nextPage.data.length === 0) break;
                      total += nextPage.data.length;
                      page++;
                      
                      // Safety limit to avoid infinite loops
                      if (page > 50) break;
                    }
                  }
                  
                  return total;
                }).catch(() => 0);
                
                // Calculate open issues count (repo.open_issues_count includes both issues and PRs)
                const openIssues = Math.max(0, (repo.open_issues_count || 0) - openPRs);
                
                // Get last activity date (only if detailed analysis is requested)
                const detailedActivityInfo = detailedActivity ? await getLastActivityDate(repo) : null;
                const lastActivity = detailedActivityInfo ? detailedActivityInfo.date : new Date(repo.updated_at);
                
                enrichedRepos.push({
                  ...repo,
                  repo_type: getRepositoryType(topics.data.names),
                  topics: topics.data.names,
                  open_issues_count: openIssues,
                  open_prs_count: openPRs,
                  last_activity_date: lastActivity,
                  detailed_activity: detailedActivityInfo, // Store detailed activity info
                  simple_activity_date: new Date(repo.updated_at) // Always store simple date for comparison
                });
                
              } catch (error) {
                console.log(`Error processing ${repo.name}: ${error.message}`);
                // Add with minimal data if API calls fail
                enrichedRepos.push({
                  ...repo,
                  repo_type: 'Other',
                  topics: [],
                  open_issues_count: repo.open_issues_count || 0,
                  open_prs_count: 0,
                  last_activity_date: new Date(repo.updated_at),
                  detailed_activity: null,
                  simple_activity_date: new Date(repo.updated_at)
                });
              }
            }
            
            console.log('Repository processing complete. Generating report...');
            
            // Generate report
            let report = `# CAMARA Project Repository Overview\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**Organization**: ${org}\n`;
            report += `**Total Repositories**: ${enrichedRepos.length}\n`;
            if (!includeArchived) {
              report += `**Archived Repositories Excluded**: ${allRepos.length - enrichedRepos.length}\n`;
            }
            report += `**Detailed Activity Analysis**: ${detailedActivity ? 'Enabled' : 'Disabled (using repository updated_at)'}\n`;
            report += `\n`;
            
            // Repository type statistics
            const typeStats = {
              'Sandbox': enrichedRepos.filter(r => r.repo_type === 'Sandbox').length,
              'Incubating': enrichedRepos.filter(r => r.repo_type === 'Incubating').length,
              'Working Group': enrichedRepos.filter(r => r.repo_type === 'Working Group').length,
              'Other': enrichedRepos.filter(r => r.repo_type === 'Other').length
            };
            
            // General statistics
            const stats = {
              total: enrichedRepos.length,
              public: enrichedRepos.filter(r => !r.private).length,
              private: enrichedRepos.filter(r => r.private).length,
              archived: enrichedRepos.filter(r => r.archived).length,
              forked: enrichedRepos.filter(r => r.fork).length,
              hasIssues: enrichedRepos.filter(r => r.has_issues).length,
              hasWiki: enrichedRepos.filter(r => r.has_wiki).length,
              languages: [...new Set(enrichedRepos.map(r => r.language).filter(l => l))],
              totalOpenIssues: enrichedRepos.reduce((acc, r) => acc + r.open_issues_count, 0),
              totalOpenPRs: enrichedRepos.reduce((acc, r) => acc + r.open_prs_count, 0)
            };
            
            report += `## Repository Statistics\n\n`;
            report += `### General Statistics\n`;
            report += `- **Total Repositories**: ${stats.total}\n`;
            report += `- **Public**: ${stats.public}\n`;
            report += `- **Private**: ${stats.private}\n`;
            if (stats.archived > 0) report += `- **Archived**: ${stats.archived}\n`;
            report += `- **Forked**: ${stats.forked}\n`;
            report += `- **With Issues Enabled**: ${stats.hasIssues}\n`;
            report += `- **With Wiki Enabled**: ${stats.hasWiki}\n`;
            report += `- **Programming Languages**: ${stats.languages.length} (${stats.languages.join(', ')})\n`;
            report += `- **Total Open Issues**: ${stats.totalOpenIssues}\n`;
            report += `- **Total Open Pull Requests**: ${stats.totalOpenPRs}\n\n`;
            
            report += `### Repository Types\n`;
            report += `- **Sandbox APIs**: ${typeStats['Sandbox']}\n`;
            report += `- **Incubating APIs**: ${typeStats['Incubating']}\n`;
            report += `- **Working Groups**: ${typeStats['Working Group']}\n`;
            report += `- **Other**: ${typeStats['Other']}\n\n`;
            
            // Activity Analysis Comparison (only if detailed analysis is enabled)
            if (detailedActivity) {
              report += `## Activity Date Comparison\n\n`;
              report += `*Comparing GitHub's updated_at vs detailed activity analysis*\n\n`;
              
              // Calculate differences
              const repositories = enrichedRepos.map(repo => {
                const simpleDate = repo.simple_activity_date;
                const detailedDate = repo.detailed_activity ? repo.detailed_activity.date : simpleDate;
                const timeDiff = Math.abs(detailedDate - simpleDate) / (1000 * 60 * 60 * 24); // days
                
                return {
                  name: repo.name,
                  repo_type: repo.repo_type,
                  html_url: repo.html_url,
                  simple_date: simpleDate,
                  detailed_date: detailedDate,
                  detailed_link: repo.detailed_activity ? repo.detailed_activity.link : repo.html_url,
                  activity_type: repo.detailed_activity ? repo.detailed_activity.type : 'repository',
                  days_difference: timeDiff
                };
              });
              
              // Find repositories with significant differences (more than 1 day)
              const significantDifferences = repositories.filter(r => r.days_difference > 1);
              const identicalDates = repositories.filter(r => r.days_difference <= 1);
              
              report += `### Summary\n`;
              report += `- **Repositories with identical/similar dates**: ${identicalDates.length}\n`;
              report += `- **Repositories with significant differences (>1 day)**: ${significantDifferences.length}\n\n`;
              
              if (significantDifferences.length > 0) {
                report += `### Repositories with Significant Date Differences\n\n`;
                report += `| Repository | Type | GitHub Updated | Detailed Activity | Difference | Activity Type |\n`;
                report += `|------------|------|----------------|-------------------|------------|---------------|\n`;
                
                // Sort by difference (largest first)
                significantDifferences.sort((a, b) => b.days_difference - a.days_difference);
                
                for (const repo of significantDifferences.slice(0, 20)) { // Show top 20
                  const simpleFormatted = repo.simple_date.toLocaleDateString();
                  const detailedFormatted = repo.detailed_date.toLocaleDateString();
                  const activityLink = `[${detailedFormatted}](${repo.detailed_link})`;
                  const daysDiff = Math.round(repo.days_difference);
                  
                  report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${simpleFormatted} | ${activityLink} | ${daysDiff} days | ${repo.activity_type} |\n`;
                }
                
                if (significantDifferences.length > 20) {
                  report += `\n*Showing top 20 of ${significantDifferences.length} repositories with differences*\n`;
                }
                report += `\n`;
              }
              
              // Sample of all repositories for comparison
              report += `### Sample Activity Date Comparison (First 15 Repositories)\n\n`;
              report += `| Repository | GitHub Updated | Detailed Activity | Activity Type |\n`;
              report += `|------------|----------------|-------------------|---------------|\n`;
              
              for (const repo of repositories.sort((a, b) => a.name.localeCompare(b.name)).slice(0, 15)) {
                const simpleFormatted = repo.simple_date.toLocaleDateString();
                const detailedFormatted = repo.detailed_date.toLocaleDateString();
                const activityLink = `[${detailedFormatted}](${repo.detailed_link})`;
                
                report += `| [${repo.name}](${repo.html_url}) | ${simpleFormatted} | ${activityLink} | ${repo.activity_type} |\n`;
              }
              report += `\n`;
            }
            
            // Repositories with least recent activity (only if detailed analysis is enabled)
            if (detailedActivity) {
              const leastActiveRepos = enrichedRepos
                .sort((a, b) => new Date(a.last_activity_date) - new Date(b.last_activity_date))
                .slice(0, 10);
              
              report += `## Repositories with Least Recent Activity\n\n`;
              report += `*Based on detailed analysis of commits, issues, PRs, and comments*\n\n`;
              report += `| Repository | Type | Last Activity | Open Issues | Open PRs | Language |\n`;
              report += `|------------|------|---------------|-------------|----------|----------|\n`;
              
              for (const repo of leastActiveRepos) {
                const lastActivity = new Date(repo.last_activity_date).toLocaleDateString();
                const language = repo.language || 'N/A';
                const isArchived = repo.archived ? ' 📦' : '';
                
                report += `| [${repo.name}](${repo.html_url})${isArchived} | ${repo.repo_type} | ${lastActivity} | ${repo.open_issues_count} | ${repo.open_prs_count} | ${language} |\n`;
              }
              report += `\n`;
            }
            
            // Top repositories by stars
            const topStarred = enrichedRepos
              .sort((a, b) => b.stargazers_count - a.stargazers_count)
              .slice(0, 10)
              .filter(r => r.stargazers_count > 0);
            
            if (topStarred.length > 0) {
              report += `## Top Repositories by Stars\n\n`;
              report += `| Repository | Type | Stars | Language | Open Issues | Open PRs |\n`;
              report += `|------------|------|-------|----------|-------------|----------|\n`;
              
              for (const repo of topStarred) {
                const language = repo.language || 'N/A';
                
                report += `| [${repo.name}](${repo.html_url}) | ${repo.repo_type} | ${repo.stargazers_count} | ${language} | ${repo.open_issues_count} | ${repo.open_prs_count} |\n`;
              }
              report += `\n`;
            }
            
            // Recent activity (using the activity date available)
            const recentlyActive = enrichedRepos
              .sort((a, b) => new Date(b.last_activity_date) - new Date(a.last_activity_date))
              .slice(0, 15);
            
            const activityTitle = detailedActivity ? 'Most Recently Active Repositories' : 'Recently Updated Repositories';
            const activityNote = detailedActivity ? '*Based on detailed activity analysis*' : '*Based on repository updated_at timestamp*';
            
            report += `## ${activityTitle}\n\n`;
            report += `${activityNote}\n\n`;
            report += `| Repository | Type | Last Activity | Open Issues | Open PRs | Language |\n`;
            report += `|------------|------|---------------|-------------|----------|----------|\n`;
            
            for (const repo of recentlyActive) {
              const lastActivity = new Date(repo.last_activity_date).toLocaleDateString();
              const language = repo.language || 'N/A';
              const isArchived = repo.archived ? ' 📦' : '';
              
              report += `| [${repo.name}](${repo.html_url})${isArchived} | ${repo.repo_type} | ${lastActivity} | ${repo.open_issues_count} | ${repo.open_prs_count} | ${language} |\n`;
            }
            report += `\n`;
            
            // Complete repository list grouped by type
            const reposByType = {
              'Working Group': enrichedRepos.filter(r => r.repo_type === 'Working Group').sort((a, b) => a.name.localeCompare(b.name)),
              'Incubating': enrichedRepos.filter(r => r.repo_type === 'Incubating').sort((a, b) => a.name.localeCompare(b.name)),
              'Sandbox': enrichedRepos.filter(r => r.repo_type === 'Sandbox').sort((a, b) => a.name.localeCompare(b.name)),
              'Other': enrichedRepos.filter(r => r.repo_type === 'Other').sort((a, b) => a.name.localeCompare(b.name))
            };
            
            report += `## Complete Repository List by Type\n\n`;
            
            for (const [type, repos] of Object.entries(reposByType)) {
              if (repos.length === 0) continue;
              
              report += `### ${type} Repositories (${repos.length})\n\n`;
              report += `| Repository | Visibility | Stars | Language | Open Issues | Open PRs | Last Activity |\n`;
              report += `|------------|------------|-------|----------|-------------|----------|---------------|\n`;
              
              for (const repo of repos) {
                const visibility = repo.private ? 'Private' : 'Public';
                const stars = repo.stargazers_count;
                const language = repo.language || 'N/A';
                const lastActivity = new Date(repo.last_activity_date).toLocaleDateString();
                const isArchived = repo.archived ? ' 📦' : '';
                
                report += `| [${repo.name}](${repo.html_url})${isArchived} | ${visibility} | ${stars} | ${language} | ${repo.open_issues_count} | ${repo.open_prs_count} | ${lastActivity} |\n`;
              }
              report += `\n`;
            }
            
            // Save report
            const fs = require('fs');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-repository-overview-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            console.log(`Report saved as ${filename}`);
            
            // Set output for artifact upload
            core.setOutput('report_filename', filename);
            
            // Add to job summary (truncated version)
            const shortSummary = report.split('\n').slice(0, 80).join('\n') + '\n\n*Full report available in artifacts*';
            core.summary.addRaw(shortSummary);
            await core.summary.write();

      - name: Generate API Releases Report
        if: github.event.inputs.report_type == 'api-releases'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            
            console.log(`Generating API releases report for ${org}`);
            
            // Get repositories with releases
            const response = await github.rest.repos.listForOrg({
              org: org,
              type: 'all',
              per_page: 100
            });
            
            const repos = response.data.filter(r => !r.archived);
            
            const repoReleases = [];
            
            for (const repo of repos) {
              try {
                const releases = await github.rest.repos.listReleases({
                  owner: org,
                  repo: repo.name,
                  per_page: 5
                });
                
                if (releases.data.length > 0) {
                  repoReleases.push({
                    name: repo.name,
                    html_url: repo.html_url,
                    releases: releases.data.map(r => ({
                      tag_name: r.tag_name,
                      name: r.name,
                      published_at: r.published_at,
                      prerelease: r.prerelease,
                      html_url: r.html_url
                    }))
                  });
                }
              } catch (error) {
                console.log(`Could not fetch releases for ${repo.name}: ${error.message}`);
              }
            }
            
            // Generate report
            let report = `# CAMARA Project API Releases\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**Repositories with Releases**: ${repoReleases.length}\n\n`;
            
            // Recent releases across all repos
            const allReleases = [];
            repoReleases.forEach(repo => {
              repo.releases.forEach(release => {
                allReleases.push({
                  repo: repo.name,
                  repo_url: repo.html_url,
                  ...release
                });
              });
            });
            
            const recentReleases = allReleases
              .sort((a, b) => new Date(b.published_at) - new Date(a.published_at))
              .slice(0, 20);
            
            report += `## Recent Releases (Last 20)\n\n`;
            report += `| Repository | Release | Version | Date | Type |\n`;
            report += `|------------|---------|---------|------|\------|\n`;
            
            for (const release of recentReleases) {
              const date = new Date(release.published_at).toLocaleDateString();
              const type = release.prerelease ? 'Pre-release' : 'Release';
              const name = release.name || release.tag_name;
              
              report += `| [${release.repo}](${release.repo_url}) | [${name}](${release.html_url}) | ${release.tag_name} | ${date} | ${type} |\n`;
            }
            
            report += `\n## Releases by Repository\n\n`;
            
            for (const repo of repoReleases.sort((a, b) => a.name.localeCompare(b.name))) {
              report += `### [${repo.name}](${repo.html_url})\n\n`;
              
              for (const release of repo.releases) {
                const date = new Date(release.published_at).toLocaleDateString();
                const type = release.prerelease ? ' (Pre-release)' : '';
                const name = release.name || release.tag_name;
                
                report += `- [${name}](${release.html_url}) - ${release.tag_name} - ${date}${type}\n`;
              }
              report += `\n`;
            }
            
            // Save report
            const fs = require('fs');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-api-releases-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            console.log(`API releases report saved as ${filename}`);
            core.setOutput('report_filename', filename);
            
            // Add to job summary
            const shortSummary = report.split('\n').slice(0, 30).join('\n') + '\n\n*Full report available in artifacts*';
            core.summary.addRaw(shortSummary);
            await core.summary.write();

      - name: Generate Workflow Status Report
        if: github.event.inputs.report_type == 'workflow-status'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CAMARA_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const org = 'camaraproject';
            
            console.log(`Generating workflow status report for ${org}`);
            
            // This is a basic implementation - you might want to enhance it
            let report = `# CAMARA Project Workflow Status\n\n`;
            report += `**Generated**: ${new Date().toISOString()}\n`;
            report += `**Note**: This is a basic workflow status report. `;
            report += `For detailed workflow analysis, consider using GitHub's API with pagination.\n\n`;
            
            report += `## Workflow Analysis\n\n`;
            report += `To get detailed workflow status:\n`;
            report += `1. Use GitHub's REST API to fetch workflow runs\n`;
            report += `2. Analyze success/failure rates\n`;
            report += `3. Identify repositories with failing workflows\n`;
            report += `4. Generate alerts for critical failures\n\n`;
            
            report += `This report type can be enhanced with specific workflow monitoring requirements.\n`;
            
            // Save report
            const fs = require('fs');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `camara-workflow-status-${timestamp.split('T')[0]}.md`;
            fs.writeFileSync(filename, report);
            
            core.setOutput('report_filename', filename);
            
            core.summary.addRaw(report);
            await core.summary.write();

      - name: Upload Report Artifact
        uses: actions/upload-artifact@v4
        with:
          name: camara-project-report-${{ github.event.inputs.report_type || 'repository-overview' }}-${{ github.run_number }}
          path: '*.md'
          retention-days: 90

      - name: Final Summary
        run: |
          echo "## Report Generation Complete" >> $GITHUB_STEP_SUMMARY
          echo "**Report Type**: ${{ github.event.inputs.report_type || 'repository-overview' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Generated At**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "**Download**: Check the artifacts section of this workflow run" >> $GITHUB_STEP_SUMMARY